<!-- micropue UI document -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Micropue | UI</title>
    <link rel="stylesheet" href="./src/micropueUI.css">
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.0/styles/intellij-light.min.css"
        integrity="sha512-rxoFrVtnfvSuel468Qr3r4djCRmFKs4DiJXUnOeaA/+uac9DkEOTEhfkcwUNiGTiA4jr6pBvXk6leEhweuGaVg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
</head>

<body>
    <div id="left-tab" class="unvisible" onselectstart="return false">
        <div class="head">
            <p class="title">列表</p>
        </div>
        <div class="container">
            <div with="lists" onclick="location.href = '#/start'" class="item">
                <p>从0开始构建micropueUI页面</p>
            </div>
            <div with="lists" onclick="location.href = '#/functions'" class="item">
                <p>函数与类</p>
            </div>
            <div with="lists" onclick="location.href = '#/models'" class="item">
                <p>组件</p>
            </div>
            <div with="lists" onclick="location.href = '#/gmicranttype'" class="item">
                <p>GmicrantType文档语法</p>
            </div>
        </div>
    </div>
    <div id="main">
        <div class="head" onselectstart="return false">
            <div class="controls">
                <div id="button-openlist" wave="rgba(171,171,171,0.5)"></div>
            </div>
            <p class="title">文档</p>
        </div>
        <div class="container"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.0/highlight.min.js"
        integrity="sha512-6QBAC6Sxc4IF04SvIg0k78l5rP5YgVjmHX2NeArelbxM3JGj4imMqfNzEta3n+mi7iG3nupdLnl3QrbfjdXyTg=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="./src/micropueUI.js"></script>
    <script>
        function a() {
            alert(Date())
        }
        const modal = new mModalBox({
            content: {
                head: {
                    first: {
                        text: "现在的时间",
                        func: a
                    },
                    title: "micropue UI组件",
                    last: {
                        text: "关闭",
                        func: modal_close
                    }
                },
                body: `MICROPUE UI是micropue开发的css与js的动态网页UI组件库，拥有自由的UI元素，搭配丰富的动画设计与界面设计。`
            }
        })
        modal.init()
        function modal_close() {
            modal.close()
        }
        const s = new PageLoader("#main .container", "#main .title", "micropue UI", "#button-back", "#button-next")
        s.init()
        const ready = new MutationObserver(() => {
            hljs.highlightAll()
        })
        ready.observe(document.querySelector("#main .container"), { childList: true, subtree: true })
        function start() {
            s.newPage("micropue UI", "<div class='page' data-enable-lists>" + GmicrantType.encode(`[h2]简介[/h2]\nMICROPUE UI是由micropue开发的JavaScript与CSS动态网页UI库。UI库拥有诸多内置的函数，类，方法供开发者使用，并且在不污染全局JS的情况下实现效果。在使用自带框架的情况下，高度兼容AJAX。\n内置框架支持左右最多三个分栏，内置了编辑器、动态页面规划实例等。\n优秀的界面设计下同时并存的还有丰富的动画。\n[hr/][h2]从0开始构建micropueUI页面[/h2]\n[h3]基础页面框架[/h3]\n将下方的代码加入到你的项目中，并引入[lcode]script[/lcode]与[lcode]css[/lcode]文件\n\n[code]<div id="left-tab" class="unvisible">\n  <div class="head">\n    <p class="title">左侧边栏标题</p>\n  </div>\n  <div class="container"></div>\n</div>\n<div id="main">\n  <div class="head">\n    <div class="controls">\n      <div id="button-openlist"></div>\n      <div id="button-back"></div><!-- 可选 -->\n      <div id="button-next"></div><!-- 可选 -->\n    </div>\n    <p class="title"></p>\n  </div>\n  <div class="container"></div>\n</div>\n<div id="right-tab" class="unvisible">\n  <div class="head">\n    <p class="title">右侧边栏标题</p>\n  </div>\n  <div class="container"></div>\n</div>[/code][hr/]左侧边栏\n\n[code]<div id="left-tab" class="unvisible">\n  <div class="head">\n    <p class="title">左侧边栏标题</p>\n  </div>\n  <div class="container"></div>\n</div>[/code]\n右侧边栏\n\n[code]<div id="right-tab" class="unvisible">\n  <div class="head">\n    <p class="title">右侧边栏标题</p>\n  </div>\n  <div class="container"></div>\n</div>[/code]\n主内容\n\n[code]<div id="main">\n  <div class="head">\n    <div class="controls">\n      <div id="button-openlist"></div>\n      <div id="button-back"></div>\n      <div id="button-next"></div>\n    </div>\n    <p class="title"></p>\n  </div>\n  <div class="container"></div>\n</div>[/code]\n其中[lcode]#container[/lcode]为各个边栏或主内容部分的主题。\n\n[tip]在移动端使用时，左右侧边栏会被隐藏至左右侧。[/tip][hr/][h3]使用MICROPUE UI的方法[/h3]\n通过[lcode]npm[/lcode]下载\n\n[code]npm install micropue-ui[/code]\n查看micropueUI仓库\n\n[link]https://github.com/Micropue/micropueUI.git[/link]\n\n使用CDN引入或下载\n\n[code]\x3Cscript src="https://unpkg.com/micropue-ui@1.0.7/src/micropueUI.js">\x3C/script>[/code]\n[code]<link rel="stylesheet" href="https://unpkg.com/micropue-ui@1.0.7/src/micropueUI.css"/>[/code][hr/][h3]页面框架的类名与ID的介绍[/h3]\n[table][table-title]框架[/table-title][tr][td][lcode]#left-tab[/lcode][/td][td]左侧边栏，在窄屏幕上会自动隐藏。[/td][/tr][tr][td][lcode]#main[/lcode][/td][td]主内容部分。[/td][/tr][tr][td][lcode]#right-tab[/lcode][/td][td]右侧边栏，在窄屏幕上会自动隐藏。[/td][/tr][tr][td][lcode].head[/lcode][/td][td]标题栏，在每个边栏或主体中都有对应样式的标题栏。[/td][/tr][tr][td][lcode].container[/lcode][/td][td]每个边栏或主体的内容承载元素。很多控件都在其内部应用样式。[/td][/tr][tr][td][lcode].title[/lcode][/td][td]在标题栏中的标题。[/td][/tr][tr][td][lcode].controls[/lcode][/td][td]在主内容部分的标题栏中的控制按钮部分，承载着控制按钮。\n在使用[lcode]initMUI()[/lcode]进行初始化时，会定位到此元素。[/td][/tr][tr][td][lcode]#button-openlist[/lcode][/td][td]打开左侧边栏的按钮，初始化UI后，此按钮在宽屏幕会不可用。\n在使用此名并使用[lcode]initMUI()[/lcode]初始化后，会自动填充图标。[/td][/tr][tr][td][lcode]#button-back[/lcode][/td][td]返回按钮，和[lcode]#button-openlist[/lcode]相同[/td][/tr][tr][td][lcode]#button-next[/lcode][/td][td]下一页按钮，和上一项相同。[/td][/tr][tr][td][lcode].unvisible[/lcode][/td][td]仅限侧边栏（左侧边栏与右侧边栏）在窄屏幕与宽屏幕切换时，默认隐藏边栏。[/td][/tr][/table][hr/][h3]框架的入门组件介绍[/h3]\n在项目中的左侧边栏一般作为列表展示，我们预装了一定的样式[lcode].item[/lcode]，在左侧边栏[lcode].container[/lcode]中填入即可。\n\n[code]<div with="lists" class="item">\n  <p>列表项 1</p>\n</div>\n<div with="lists" class="item">\n  <p>列表项 2</p>\n</div>\n<div with="lists" class="item">\n  <p>列表项 3</p>\n</div>[/code]\n为了方便，我们提供了使用[lcode]PHP[/lcode]作为后端进行数据交互的示例代码：\n\n[code]<div id="left-tab">\n  <div class="head">\n    <p class="title">列表</p>\n  </div>\n  <div class="container">\n  \x3C!-- 通过while循环遍历数据库数据，并进行输出 -->\n    <?php while ($row = $rst->fetch_assoc()){ ?>\n    \x3C!-- 通过此方法，将每个item填入数据。 -->\n        <div class="item">\n          <p><?php echo $row['title']; ?></p>\n        </div>\n    <?php } ?>\n  </div>\n</div>\n[/code]\n[tipblock]如果想要点击的选中效果，可以添加[lcode]with[/lcode]属性例如上面的示例代码。[lcode]with[/lcode]属性会自动为元素添加[lcode]click[/lcode]事件，并同单选框类似在选中后会添加[lcode]active[/lcode]类名。\n使用时，可以为他添加[lcode]onclick[/lcode]属性，调用自定义函数来与[lcode]PageLoader[/lcode]类实现动态的页面切换。[/tipblock]\n在主内容部分，为了开发方便，我们预装了[lcode].page[/lcode]和[lcode].paper[/lcode]类名来使用。\n\n[tipblock]默认会有1.8倍行距，20px的内间距。[/tipblock][hr/][h3]使用PageLoader类构建动态页面规划实例[/h3]\n[lcode]Pageloader[/lcode]是UI库为了开发者在相同页面内实现类似多页面切换的功能打造的。\n在引入UI的[lcode]JavaScript[/lcode]文件后，使用[lcode]new PageLoader()[/lcode]来声明与配置。\n下面是一个配置的例子：\n\n[code]const page = new PageLoader("#main .container", "#main .head .title", "默认标题", "#button-back", "#button-next")\n//声明一个新的PageLoader类。其中#button-back和#button-next可选，如果认为效果不佳则填入空即可。\npage.init()\n//初始化\npage.next()\n//下一页\npage.back()\n//上一页\npage.newPage()\n//新建页面\n[/code]\n[warnblock]强烈建议使用此UI库的[lcode]HTML[/lcode]框架进行[lcode]PageLoader[/lcode]配置。\n并且，[lcode]PageLoader[/lcode]仅针对此框架进行优化，如果你想在别的地方使用这个类，可以尝试到UI库的[lcode]Javascript[/lcode]文件中修改。\n[lcode]PageLoader[/lcode]将会自动检测表单，并保存相应的表单输入内容。[/warnblock]\n参数配置：\n[table][table-title]参数配置[/table-title][tr][td]方法[/td][td]介绍[/td][/tr][tr][td][lcode]new PageLoader(main,title,defaultTitle,backButton,nextButton)[/lcode][/td][td]声明一个新的[lcode]PageLoader[/lcode]类并进行配置；\n[lcode]main[/lcode]为应用元素；\n[lcode]title[/lcode]为标题元素；\n[lcode]defaultTitle[/lcode]为默认标题；\n[lcode]backButton[/lcode]返回按钮的元素；\n[lcode]nextButton[/lcode]下一页按钮。\n全部的元素查询都会自动进行。所以进行参数配置时只需要将对应的字符串传入即可。[/td][/tr][tr][td][lcode]init()[/lcode][/td][td]初始化，会自动配置页面，包括按钮的可用，主页和默认标题的显示。[/td][/tr][tr][td][lcode]newPage(title,content,func)[/lcode][/td][td]新建页面\n[lcode]title[/lcode]新页面标题，会自动显示在指定的元素上。\n[lcode]content[/lcode]新页面的内容。[/td][/tr][tr][td][lcode]next(func)[/lcode][/td][td]下一页[/td][/tr][tr][td][lcode]back(func)[/lcode][/td][td]上一页[/td][/tr][/table]\n其中[lcode]func[/lcode]是一个函数，在完成页面切换动作后会自动执行传入函数。\n\n[warnblock]无法自动存储事件监听器的绑定，由于元素的更新，会导致事件监听器的注销。建议在页面中应用事件监听器时，同时注册重新加载函数，这样在切换页面传入该函数即可重新绑定事件。[/warnblock]\n为了优化体验，我们加入了[lcode][data-page-loader-cantuse][/lcode]属性。可以为包含此属性的元素在页面切换发生时自动遮盖并显示[lcode]页面切换时无法使用，重新进入功能以启用。[/lcode]\n\n[tipblock]会自动保存表单内容与滚动距离\n点击顶部标题可以一键回到顶部。[/tipblock]\n[hr/]更多组件可以详见组件页面。`) + "</div>")
        }
        function functionsAndMethods() {
            s.newPage("函数与类", `<div class="page" data-enable-lists>${GmicrantType.encode(`[h2]函数与类[/h2]\n使用MICROPUE UI库的内置函数快速实现功能。\n[hr/][h3]mDOM[/h3]\n虚拟DOM生成器，通过调用此类免去在构建动态页面组件时过多字符串存储html的问题。\n示例代码：\n\n[code]new mDOM({\n    head:{\n        _options_:{\n            text:"网页头部"\n        }\n    },\n    body:{\n        _options_:{\n            attrs:{id:"main"},\n            text:"内容",\n            events:{click:()=>console.log("点击了内容"),mouseover:()=>console.log("鼠标进入了！")}\n        }\n    },\n    foot:{\n        _options_:{\n            attrs:{id:"foot"},\n            text:"页脚"\n        },\n        a:{\n            attrs:{href:"https://github.com"},\n            text:"前往仓库Github->",\n        }\n    }\n},"body")[/code]\n[b]什么是虚拟DOM（virtual DOM）？[/b]\n在MICROPUE内置的工具函数的定义，通过一个对象来动态构建的元素就称之为虚拟DOM。在不懂[lcode]vue[/lcode]这种框架而想使用单页应用又过于繁琐，所有的HTML都需要存储在[lcode]javascript[/lcode]文件中。使用此类可以通过定义对象的这种方式可视化的生成DOM，免去了易读性差的字符串存储HTML。\n[b]对比：[/b]\n[s]复杂的字符串存储：[/s]\n[code]const ele = \`<div class="head"><p>标题</p></div><div class="body"><p>内容</p></div>\`[/code]\n实际开发中可能更复杂，且部分编辑器对字符串不会高量化。\n[color:green]使用[lcode]mDOM[/lcode]存储DOM：[/color]\n[code]const ele = {\n    head: {\n        p: {\n            _options_: {\n                text: "标题栏"\n            }\n        }\n    },\n    body: {\n        p: {\n            _options_: {\n                text: "内容"\n            }\n        }\n    }\n}[/code]\n并且便于管理点击事件、包括对应HTML的任何事件。\n[b]详细使用[/b]\n[code]new mDOM({\n    head: {\n        p: {\n            _options_: {\n                attrs:{class:"head p"},\n                text: "标题栏",\n                events:{click:()=>{}}\n            }\n        }\n    },\n    body: {\n        p: {\n            _options_: {\n                text: "内容"\n            }\n        }\n    }\n})[/code]\n通过定义一个DOM树对象，支持多层嵌套，会根据自对象的嵌套方式进行元素嵌套。\n[lcode]_options_[/lcode]是保留关键字，用于指定该元素的相关属性：\n\n[table][table-title]_options_属性[/table-title][tr][td][lcode]attrs[/lcode][/td][td]该元素的标签属性。\n通过[lcode]name:value[/lcode]的方式进行声明，支持多个。[/td][/tr][tr][td][lcode]text[/lcode][/td][td]元素的内容部分，在支持的元素中会在标题那内填入内容（[lcode]innerText[/lcode]）[/td][/tr][tr][td][lcode]events[/lcode][/td][td]注册事件监听器。\n通过[lcode]name:function[/lcode]的方式注册；\n[lcode]name[/lcode]代表监听器的名称；\n[lcode]function[/lcode]为回调函数[/td][/tr][/table]\n[tipblock]可以通过变量存储，调用mDOM后会立即在页面上升成。[/tipblock]\n[lcode]_options_[/lcode]也可以不添加，所有属性都可选择性声明。\n注册空元素：\n[code]new mDOM({\n    p:{}\n})[/code]\n使用javascript的对象声明方法，在注册空元素时请添加大括号。[hr/][h3]RouteLoader[/h3]\n用于单页应用的路由规划类。通过此类可以实现不刷新页面的情况下更新地址、更新页面等。\n示例代码：\n\n[code]const routes = [\n    ["/start/id/{%}",(param,query)=>{\n         console.log(param,query)\n    }],\n    ["/functions",functionsAndMethods],\n    ["/models",models],\n    ["/gmicranttype",gmicrant]\n]\nnew RouteLoader(routes)[/code]\n[b]定义路由表[/b]\n通过定义路由表来指定每个地址的操作。\n\n[code]const routes = [\n    [地址, 回调函数],\n    ...\n]\n[/code]\n在路径中可以通过关键字[lcode]{%}[/lcode]来指明URL参数，在指定后可以通过回调函数获取到相应的数组。\n并且支持通过[lcode]?query=value[/lcode]的方式来匹配。例如：\n[s][/s]\n[code]const route = [\n    ["/s/{%}/content/{%}/",(param,query)=>{\n        console.log(param,query)\n    }]\n]\n//假设地址为:http://123.com/s/hello/content/123/?id=123&v=0.9\n//浏览器会输出：["hello","123"],{id:"123",v:"0.9"}\n[/code]\n[red]但是请注意⚠️[/red]：在使用[lcode]?query=value[/lcode]类型的查询参数时，请务必在路径匹配时在后面加入[lcode]/[/lcode]例如：\n\n[code]const route = [\n    ["/s/",(param,query)=>{\n        //执行操作\n    }]\n]\n//即在[lcode]s[/lcode]的后面加入[lcode]/[/lcode][/code]\n否则可能会导致匹配不正确或将[lcode]?[/lcode]匹配。\n\n[b]回调函数的两个参数分别是[lcode]在地址中匹配的参数[/lcode]和[lcode]?[/lcode]即query查询参数。前者为数组，后者为对象，在使用回调函数操作时，请加以注意。[/b]\n[tipblock]回调函数可以是任意的执行，可以通过动态页面规划实例：[lcode]PageLoader[/lcode]来实现在micropueUI框架的基础上更新页面。[/tipblock]\n[b]声明RouteLoader[/b]\n\n[code]new RouteLoader(路由表)[/code]\n\n通过此方法可以定义一个新的路由规划实例。\n一个页面内允许同时存在多个路由规划实例，包括路径的叠加例如：\n\n[code]new RouteLoader([\n    ["/components",home],\n    ["/functions",functions]\n])\n//更加的细分\nnew RouteLoader([\n    ["/components/input",input],\n    ["/components/line",line]\n])\n[/code]\n当然如果你使用AJAX进行数据交互，也可以动态生成路由表，并指定你要执行的函数。\n[tipblock]路由会在进入页面时就开始执行，如果你进入时的[lcode]hash[/lcode]值是与路由对应匹配的也会执行对应函数。[/tipblock]\n该类会通过在地址中添加[lcode]#[/lcode]即[lcode]hash[/lcode]的方式进行处理，避免了后端处理的麻烦。当然路由不仅仅使用类似路径的样式，也可以自定义。\n[code]new RouteLoader([\n    ["文本框",input],\n    ["横线",line]\n])[/code]\n\n[warnblock]应当尽量避免路由或[lcode]hash[/lcode]值冲突的问题。[/warnblock][hr/][h3]mAjax[/h3]\n用于发送[lcode]ajax[/lcode]请求，基于[lcode]XMLHttpRequest()[/lcode]封装。\n示例代码：\n[code]const ajax = new mAjax({\n    url:"https://api.example.com/post",\n    method:"POST",\n    data:{\n        a:1,\n        b:2,\n        c:3\n    },\n    success:(status,data)=>{\n        //请求成功时的回调函数\n    },\n    error:(status,data)=>{\n       //请求失败的回调函数\n    }\n})\nsetTimeout(() => ajax.abort(),3000)//3秒后终止请求[/code]\n配置参数：\n\n[table][tr][td][lcode]url[/lcode][/td][td]请求地址[/td][/tr][tr][td][lcode]method[/lcode][/td][td]请求方法[/td][/tr][tr][td][lcode]data[/lcode][/td][td]携带数据[/td][/tr][tr][td][lcode]success[/lcode][/td][td]请求成功的回调函数[/td][/tr][tr][td][lcode]error[/lcode][/td][td]请求失败的回调函数[/td][/tr][table-title]方法[/table-title][tr][td][lcode]abort[/lcode][/td][td]终止请求[/td][/tr][/table]\n支持所有的[lcode]HTTP[/lcode]请求方法，但是当前只适配了[lcode]POST[/lcode]和[lcode]GET[/lcode]的数据收发。\n\n[tipblock]在使用[lcode]GET[/lcode]方法携带数据时，会自动将数据转换为[lcode]query[/lcode]地址查询参数：\n\n[code]https://api.example.com/post/?a=1&b=1[/code]并且在使用[lcode]POST[/lcode]请求时，会自动设置请求头为[lcode]Content-Type：application/x-www-form-urlencoded; charset=UTF-8[/lcode]并且使用表单数据格式进行发送。[/tipblock]\n其中[lcode]success(status,data)[/lcode]和[lcode]error(status,data)[/lcode]会回调相同类型的数据。\n[lcode]status[/lcode]中有两个参数：\n\n[code]status:{\n    readyState:xhr.readyState, //XHR对象的状态码一般为4\n    status:xhr.status //请求的HTTP请求状态码\n}[/code]\n[lcode]data[/lcode]如果返回的数据时JSON格式，会自动将数据转换为对象。所以在使用返回数据时，可以直接使用对象的调用方法。[hr/][h3]mCookie[/h3]\n快捷的进行[lcode]cookie[/lcode]操作\n示例代码：\n\n[code]mCookie.set({\n    key:"myCookie", //cookie的名称\n    value:"hello world", //cookie的值 不设置则为空\n    path:"./", //cookie路径 不设置则为“/”\n    expires:10000, //cookie的有效时间（秒）不设置则为一天\n    secure:true, //是否仅在HTTPS时传输cookie 不设置则为false\n    sameSite:"None" //防止跨站请求伪造攻击，有 Lax、Strict 和 None 选项 不设置则为Lax\n}) //设置cookie\nmCookie.all() //获取所有cookie（返回对象）\nmCookie.get("myCookie") //存在时返回对应值，不存在返回false\nmCookie.delete("myCookie","./") //删除cookie\n[/code]\n所有字段都可以选择性填写（除了[lcode]key[/lcode]字段）\n\n[tipblock]当设置[lcode]cookie[/lcode]时，并且[lcode]sameSite[/lcode]字段设置为[lcode]None[/lcode]则[lcode]secure[/lcode]必须为[lcode][b]true[/b][/lcode][/tipblock][hr/][h3]TypeEffect（打字机）[/h3]\n示例：\n\n[code]new TypeEffect(element, texts, seconds,everyStopSeconds)\n[/code]\n参数配置：\n\n[table][tr][td][lcode]element[/lcode][/td][td]操作元素，应用效果元素（不应该有内容）[/td][/tr][tr][td][lcode]texts[/lcode][/td][td]文本数组，[“第一句话”,”第二句话”][/td][/tr][tr][td][lcode]seconds[/lcode][/td][td]每个单词或字的间距时间ms[/td][/tr][tr][td][lcode]everyStopSeconds[/lcode][/td][td]每句话的间距时间ms[/td][/tr][/table]\n[lcode]type()[/lcode]方法 开始执行动画\n[lcode]clear(显示文字，秒)[/lcode]方法 在执行动画结束后，最后显示的文字。\n\n[tipblock]在[lcode]type()[/lcode]方法中，会返回执行结束的对应秒数。[/tipblock]\n[code]const t = new TypeEffect("#main",[\n  "打字机效果",\n  "动态打字机效果"\n],100,500)\n//声明一个新的打字机效果\nconst s = t.type()\n//开始打字\nt.clear("打字结束",s)\n//打字结束后显示的效果。\n[/code]\n上面的代码将在[lcode]#main[/lcode]上执行一个打字机动画，结束文本为“打字结束”。[hr/][h3]initMUI()[/h3]\n重新加载或初始化micropue UI。\n调用此函数，仅会填充框架所需的图标。\n\n[tipblock]必须元素：[lcode]#button-openlist[/lcode][lcode]#button-back[/lcode][lcode]#button-next[/lcode]通过此函数将会在这是三个元素上填充图标。\n默认会在页面加载完成时执行。[/tipblock][hr/][h3]wave()[/h3]\n重新加载或初始化应用波纹动画的元素。\n在所需元素标签上添加[lcode][wave="颜色"][/lcode]属性即可执行效果。\n\n[tipblock]由于元素使用了事件监听器，不要重复调用[lcode]wave()[/lcode]会使事件监听器叠加导致波纹动画异常。\n标签内的[lcode]wave[/lcode]属性值只需使用css的颜色格式即可。如[lcode]wave="rgba(255,255,255,0.5)"[/lcode]\n默认情况下，在页面加载完成后会自动执行。[/tipblock]\n示例：\n\n[code]<button wave="black">这是一个加载了波纹动画的按钮</button>[/code]\n在需要时调用\n\n[code]wave()[/code]\n[hr/][h3]escapeHtml(str)[/h3]\n将html转换为html实体。\n反向转换：[lcode]decodeHtml(HTML)[/lcode]\n[hr/][h3]enableCodePre()[/h3]\n启用或重新加载HTML自动转换。在使用[lcode].code[/lcode]css类时，调用此函数会将[lcode].code[/lcode]中承载的内容进行实体化。\n\n示例：\n[code]<div class="code">\n  <!DOCTYPE html>\n  <html></html>\n</div>[/code]\n此代码会被自动转换为HTML实体，默认不启用。\n\n[warnblock]启用后会被加载速度所影响。\n在未加载完成时可能会出现代码被执行。\n不推荐使用。[/warnblock][hr/][h3]PageLoader[/h3]\n动态页面规划类\n搭配micropueUI框架使用可以实现在无需新建标签页的情况下多页面进行切换。并有丰富的动画加持。\n[blue][b]详情可以查看[lcode]从0开始构建micropueUI页面[/lcode]的最后一条。[/b][/blue]\n[hr/][h3]GmicrantType[/h3]\n格式化文档或对文档解码。仅支持[lcode]GmicrantType[/lcode]语法。\n\n[table][tr][td][lcode]encode(str)[/lcode][/td][td]编码为HTML[/td][/tr][tr][td][lcode]decode(str)[/lcode][/td][td]对HTML解码为[lcode]GmicrantType[/lcode]语法代码[/td][/tr][/table]\n[hr/][h3]HTMLElement.insertFromSelection(start,end,str)[/h3]\n在表单元素上的固定位置插入内容。\n通过对元素调用此方法并传入光标起始以及结束位置插入内容。\n示例：[code]const text = document.getElementById("textarea")\nconst mouse = {\n  start:text.selectionStart,\n  end:text.selectionEnd\n}\ntext.insertFromSelection(mouse.start,mouse.end,["<h1>","</h1>"])\n[/code]\n[tipblock]传入的[lcode]str[/lcode]只能为数组，可以为一个元素或两个元素。[/tipblock][hr/]\n[h3]BuiltGmicrantType[/h3]\n在指定位置生成一个[lcode]GmicrantType[/lcode]编辑器。\n[blue][b]详情可以查看[lcode]GmicrantType文档语法[/lcode]页。[/b][/blue]\n[hr/][h3]shuffle()[/h3]\n可以对数组或对象进行打乱。\n\n[tipblock]为了不污染全局，我们没有使用函数而是方法。[/tipblock]\n示例：\n\n[code]let s = [1,2,3,4,5,6]\nlet a = {a:1,b:2,c:3,d:4,e:5}\ns.shuffle()\n//没有返回值\na.shuffle()\n//没有返回值并不会打乱索引。\n[/code]`)}</div>`)
        }
        const mwindow = new mWindow({
            size: {
                width: 500,
                height: 300
            },
            defaultLocation: {
                x: 100,
                y: 200
            },
            bgcolor: "white",
            zIndex: 100000,
            head: {
                title: "测试",
                controls: [
                    {
                        name: "关闭", func: windowClose
                    }
                ]
            },
            content: "MICROPUE窗口"
        })
        mwindow.init()
        function windowClose() { mwindow.close() }
        function models() {
            s.newPage("组件", `<div class="page" data-enable-lists>${GmicrantType.encode(`[h2]内置组件[/h2]\n使用MICROPUE UI内置组件更快速的编写前端代码。\n部分组件继承[lcode]HTMLELement[/lcode]，所以支持原生的如[lcode]click[/lcode][lcode]mouseover[/lcode]等事件。\n[hr/]\n[h2]组件[/h2]\n所有组件的介绍都将以css选择器的形式展现。\n\n[h3]按钮[/h3]\n[lcode].button[/lcode] 默认样式（白色）的按钮\n[lcode].black-button[/lcode] 黑色按钮，hover 效果变为白底\n[lcode].red-button[/lcode] 红色按钮\n\n[b]框架：[/b]\n\n[lcode]#button-openlist[/lcode] 打开侧边栏按钮，自动加载图标，无需手动插入，调用全局函数[lcode]initMUI()[/lcode]\n[lcode]#button-back[/lcode] 返回上一页按钮，自动加载图标\n[lcode]#button-next[/lcode] 下一页按钮，自动加载图标\n\n[lcode]m-button[/lcode] 效果按钮\nMICROPUE UI的内置效果按钮，拥有鼠标移入的辉煌效果。\n\n[tipblock]此按钮继承于[lcode]HTMLElement[/lcode]，支持所有的事件。[/tipblock]\n示例：\n\n`)+`<m-button>试一试</m-button>`+GmicrantType.encode(`\n代码\n\n[code]<m-button>试一试</m-button>[/code]\n[b]支持自定义样式但是需要通过[red]标签属性[/red]设置[/b]。\n代码：\n[code]<m-button mui-width="100" mui-height="80" shadow-color="blue"></m-button>[/code]\n[lcode][mui-width][/lcode]设置宽度，可选默认情况下[lcode]80px[/lcode]；\n[lcode][mui-height][/lcode]设置款对，可选默认情况下[lcode]40px[/lcode]；\n[lcode][shadow-color][/lcode]设置辉光颜色和按钮的背景颜色，可选默认情况下使用默认主题色变量进行设置（[lcode]--theme-color[/lcode]）。支持所有的css颜色。\n\n[lcode]m-switch[/lcode]\n开关，用于替换[lcode]checkbox[/lcode]。\n示例：`)+`<m-switch checked="true"></m-switch>`+GmicrantType.encode(`\n示例代码：\n\n[code]<m-switch checked="true"></m-switch>[/code]\n[b]参数：（标签属性）[/b]\n[lcode]checked[/lcode]是否打开，支持动态更改。\n[lcode]disabled[/lcode]添加该属性表示已禁用，不要给定值。\n[lcode]size[/lcode]开关大小，不设置时为20\n\n[code]<m-switch checked="true" disabled></m-switch>\n\x3C!-- 禁用开关 -->[/code]\n通过调用元素的[lcode]checked[/lcode]方法可以查看到是否已经打开：[lcode]true[/lcode]打开，[lcode]false[/lcode]关闭。如果认为通过元素调用方法不好用，可以直接调用元素的[lcode]getAttribute("checked")[/lcode]方法查看。\n\n[warnblock]不要尝试修改方法的值，因为没有任何效果。[/warnblock][hr/]\n[h3]效果[/h3]\n[lcode][wave=颜色][/lcode]\n\n用于为元素添加点击波纹动画。其中[b]颜色[/b]可以为css的任何形式的颜色。\n示例代码：\n\n[code]<button wave="gray">按钮</button>[/code]\n[tipblock]不支持动态添加，默认只会在完成页面加载后渲染。可以调用[lcode]wave()[/lcode]来重新初始化。并且此方法不会导致叠加。[/tipblock]\n添加[lcode]wave[/lcode]属性的元素会在元素上添加[lcode]data-iswave[/lcode]来检查是否初始化动画。\n\n[lcode].scroll-smooth[/lcode]平滑滚动。\n[hr/]\n[h3]表格与列表[/h3]\n[lcode]m-table[/lcode]\n\nUI库的内置表格，不支持合并单元格。\n[lcode]m-table-title[/lcode]表格标题\n[lcode]m-tr[/lcode]表格横行\n[lcode]m-td[/lcode]表格纵列\n与普通HTML表格一样但是不支持原生的css属性。\n\n[code]<m-table>\n    <m-table-title>电话</m-table-title>\n    <m-tr>\n        <m-td>序号</m-td>\n        <m-td>姓名</m-td>\n        <m-td>电话</m-td>\n    </m-tr>\n    <m-tr>\n        <m-td>1</m-td>\n        <m-td>小明</m-td>\n        <m-td>123****8910</m-td>\n    </m-tr><m-tr>\n        <m-td>2</m-td>\n        <m-td>小红</m-td>\n        <m-td>123****8910</m-td>\n    </m-tr>\n</m-table>[/code]\n\n[lcode][with=跟踪项][/lcode]\n\n用于生成单选列表，为列表项添加相同的[lcode]with[/lcode]属性值，在点击此属性值的元素时会添加上[lcode].active[/lcode]类。\n示例代码：\n\n[code]<div class="item" with="radio">选项1</div>\n<div class="item" with="radio">选项2</div>\n<div class="item" with="radio">选项3</div>\n\x3C!-- 在三个选项之间切换 --> \n[/code]\n不同的列表之间互不影响，只要[lcode]with[/lcode]属性值不同即可。\n\n[tipblock]没有内置的[lcode].active[/lcode]样式。需要自行编写。[/tipblock]\n[hr/]\n[h3]富文本效果[/h3]\n[lcode]p.tip[/lcode] 提示文本，默认会存在[lcode]20px[/lcode]的内间距。在[lcode]#main .container[/lcode]中没有间距。\n[lcode]span.red-circle[/lcode] 红色圆点。\n[lcode]span.green-circle[/lcode] 绿色圆点。\n[lcode].code[/lcode]代码块 必须加入[lcode]p[/lcode]标签，否则字体不生效。\n[lcode]span.lblock[/lcode] 为引入的文字加入类似突出的样式（小代码块）。\n[lcode]m-hr[/lcode] 一条横向虚线。\n[lcode]m-lhr[/lcode] 一条竖向虚线。\n[lcode].h1 .h2 .h3 .h4[/lcode] 带有左侧蓝色边线的标题\n[lcode].tipblock[/lcode] 块提示文本\n[lcode].warnblock[/lcode] 块警示文本\n[hr/]\n[h3]侧边栏，页面[/h3]\n[lcode]#left-tab [/lcode]左侧边栏，自动适配小屏幕。建议添加.unvisible类。\n[lcode]#right-tab[/lcode] 右侧边栏，建议添加.unvisible类。\n[lcode]#main[/lcode]主页面。\n在框架简介中有详细介绍。\n[hr/]\n[h3]输入框与表单[/h3][lcode].textarea[/lcode] 文本域，应用于[lcode]textarea[/lcode]上。支持自适应高度显示内容，并有默认样式。\n\n[lcode]m-input[/lcode]\n内置的效果输入框，支持鼠标的辉光动画。\n示例：\n`)+`<m-input type="password" placeholder="输入密码"></m-input>`+ GmicrantType.encode(`\n代码：\n[code]<m-input type="password" placeholder="输入密码"></m-input>[/code]\n[b]配置（标签属性）[/b]\n[lcode]type[/lcode]表单类型，支持[lcode]text[/lcode],[lcode]password[/lcode]等文本输入类型。默认为[lcode]text[/lcode]\n[lcode]placeholder[/lcode]输入框的提示文本，在聚焦或有内容时消失。默认为[lcode]输入...[/lcode]\n[lcode]mui-bgcolor[/lcode]聚焦时输入框的背景颜色。默认为主题色[lcode]--theme-color[/lcode]。\n[lcode]shadow-color[/lcode]辉光颜色。默认为透明主题色[lcode]--rgba-theme-color[/lcode]。\n在不设置[lcode]width[/lcode]和[lcode]height[/lcode]时，默认为[lcode]150px[/lcode]和[lcode]50px[/lcode]\n\n[tipblock]支持所有种类的[lcode]css[/lcode]颜色。[/tipblock]\n组件继承[lcode]HTMLELement[/lcode]，但是使用[lcode]shadowRoot[/lcode]封装了原生的元素进行功能实现，所以组件不支持原生的[lcode]input[/lcode]、[lcode]change[/lcode]、[lcode]focus[/lcode]等表单类事件，包括[lcode]value[/lcode]值的获取都无法直接通过组件获取。\n[b]如果你想使用表单的原生事件，需要通过[lcode]shadowRoot[/lcode]进行获取元素。[/b]\n示例代码：\n\n[code]const input = document.querySelector("m-input")\n.shadowRoot.querySelector("input") //从shadowRoot阴影中获取元素\ninput.addEventListener("input",()=>{\n    //原生事件\n})\ninput.addEventListener("change",()=>{\n    //原生事件\n})\nconsole.log(input.value) //获取值[/code]\n[warnblock]辉光效果在safari中可能渲染错误。[/warnblock]\n\n[lcode]m-select[/lcode]下拉列表\n示例代码：\n\n[code]<m-select>\n    <m-select-view>\n        排序\n    </m-select-view>\n    <m-select-options>\n        <m-option value="bytime" selected>按时间</m-option>\n        <m-option value="bylatest">最早</m-option>\n    </m-select-options>\n</m-select>[/code]\n[tipblock]在[lcode]m-select-view[/lcode]中会自动生成图标，并更改元素结构。所以不建议在此元素添加其他内容。[/tipblock]\n[lcode]m-option[/lcode]的[lcode]value[/lcode]属性用于指定值，调用元素的[lcode].value[/lcode]方法可以获取到当前选中的值。[red]只支持点击事件，如果用其他方法触发则值可能出现错误[/red]。示例代码：\n\n[code]const ele = document.querySelector("m-select")\n//获取元素\nconsole.log(ele.value)\n//输出当前选中的值即对应属性value的值。\n[/code]\n注意⚠️：有默认样式。\n[lcode]selected[/lcode]用于指定默认选中项，在切换选中项目时也会改变。\n调用元素的[lcode]is_open[/lcode]方法可以检查是否已经打开。\n\n[table][table-title]方法[/table-title][tr][td][lcode]value[/lcode][/td][td]用于获取当前选中的目标。[/td][/tr][tr][td][lcode]is_open[/lcode][/td][td]用于查看是否已经打开。[/td][/tr][/table]\n[tipblock]支持动态添加并继承于[lcode]HTMLElement[/lcode]原型[/tipblock]\n\n[lcode]m-menu[/lcode]菜单\n生成自定义菜单，初始化一个触发元素即可使用。\n\n[code]<m-menu for=".open-element">\n    <m-option>第一项</m-option>\n    <m-option>第二项</m-option>\n    <m-option>第三项</m-option>\n    <m-option>第四项</m-option>\n</m-menu>[/code]\n其中[lcode]for[/lcode]属性用于指定触发元素，点击此元素会打开或关闭菜单。当然如果你点击外部也会关闭。\n\n[tipblock][lcode]for[/lcode]属性中直接使用[lcode]css[/lcode]选择器即可。并且会选择全局的元素。[/tipblock]\n可以通过一些方法对菜单操作：\n\n[code]const ele = document.querySelector("m-menu")\n//获取菜单元素\nele.open()        //打开菜单\nele.close()       //关闭菜单\nele.is_opened     //查看是否已经打开\n[/code]\n⚠️注意：此元素初始化后会自动在元素上生成一个[lcode]mui-isopen[/lcode]属性来指定是否已经打开。\n\n[table][table-title]方法[/table-title][tr][td][lcode]open()[/lcode][/td][td]打开菜单[/td][/tr][tr][td][lcode]close()[/lcode][/td][td]关闭菜单[/td][/tr][tr][td][lcode]is_opened[/lcode][/td][td]是否打开[/td][/tr][/table]\n[hr/]\n[h3]功能[/h3]\n[lcode][data-enable-lists][/lcode]用于为当前元素生成大纲，会自动识别元素内的H1～H6标题并整理成有序列表。\n\n[warnblock]针对[lcode].page[/lcode]兼容，会自动添加滚动动画，但是在部分浏览器中不生效。不建议应用到其他元素。[/warnblock]\n有序列表会自动生成在父元素或者称为当前元素的上面（同级）。\n[hr/]\n[h3]图标[/h3]\nMICROPUE UI内置了一些图标，通过[lcode]m-icon[/lcode]生成图标。\n通过指定[lcode]size[/lcode],[lcode]color[/lcode]来自定义大小或颜色，若不设置默认28px灰色。\n\n[tipblock]支持动态修改，如果你修改了标签内属性的值支持实时更新样式。[/tipblock]\n示例：\n\n[code]<m-icon type="select" size="28" color="black"></m-icon>[/code]\n下面是所有的图标：\n\n[code]<m-icon type="search"></m-icon> 搜索图标\n<m-icon type="down"></m-icon> 向下箭头\n<m-icon type="select"></m-icon> 多选图标\n<m-icon type="add"></m-icon> 新建图标\n<m-icon type="cancel"></m-icon> 叉图标\n<m-icon type="info"></m-icon> 更多信息图标\n<m-icon type="more"></m-icon> 更多图标\n<m-icon type="warn"></m-icon> 警告图标\n<m-icon type="undo"></m-icon> 撤销图标\n<m-icon type="redo"></m-icon> 重做图标[/code]\n[hr/][h3]弹窗与提示[/h3]\n[lcode]mModalBox[/lcode] 生成并操作一个复杂弹窗。\n\n[tipblock]这是一个全局对象，在为变量或函数命名时，不要与其冲突。[/tipblock]\n示例代码：\n\n[code]const modal = new mModalBox({\n    where:"css选择器，点击此元素打开"\n    content: {\n        head: { //弹窗头部\n            first: {\n                text: "按钮1文本",\n                func: //按钮1点击执行的函数\n            },\n            title: "弹窗标题",\n            last: {\n                text: "按钮2文本",\n                func: //按钮2点击执行的函数\n            }\n        },\n        body: \`\` //弹窗内容部分，插入html字符串即可。\n    }\n})\nmodal.init() //初始化\nmodal.open() //打开\nmodal.close() //关闭\nmodal.logout() //注销组件，删除组件\nmodal.update() //更新内容\nmodal.uid //弹窗的唯一ID\nmodal.is_opening //是否打开[/code]\n\n其中[lcode]where[/lcode]的配置也可以省略，使用时注意使用CSS选择器。\n调用[lcode]update[/lcode]方法，支持html字符串。\n\n[tipblock]在初始化后，会在HTML文档的最下方加入标签，并且在[lcode]m-modal[/lcode]标签中会初始化[lcode]mui-isopen[/lcode]和[lcode]mui-uid[/lcode]字段。[/tipblock]\n下面是一个运行的实例：\n\n[code]function a() {\n    return Date()\n}\nconst modal = new mModalBox({\n    content: {\n        head: {\n            first: {\n                text: "现在的时间",\n                func: a\n            },\n            title: "micropue UI组件",\n            last: {\n                text: "关闭",\n                func: modal_close\n            }\n        },\n        body: \`MICROPUE UI是micropue开发的css与js的动态网页UI组件库，拥有自由的UI元素，搭配丰富的动画设计与界面设计。\`\n    }\n})\nmodal.init()\nfunction modal_close() {\n    modal.close()\n}[/code]\n生成的HTML:\n\n[code]<m-modal mui-isopen="false" mui-uid="MTQ1M-jYuN-zM0N-DY3N-TM2" style="display: none">\n    <m-modal-page>\n        <m-modal-head>\n            <p m-modal-head-first-button="">现在的时间</p>\n            <p m-modal-head-title="">micropue UI组件</p>\n            <p m-modal-head-last-button="">关闭</p>\n        </m-modal-head>\n        <m-modal-body>\n            MICROPUE UI是micropue开发的css与js的动态网页UI组件库，拥有自由的UI元素，搭配丰富的动画设计与界面设计。\n        </m-modal-body>\n    </m-modal-page>\n</m-modal>[/code]\n`) + `<a href="javascript:modal.open()">点击此处执行</a>` + GmicrantType.encode(`\n\n[tipblock]由于使用自定义标签，不会影响实际的css样式。\n不支持动态定义，如果你插入标签到HTML，它将不会生效。\n避免层叠上下文或自定义[lcode]z-index[/lcode]。默认[lcode]z-index[/lcode]值为10000。\n所有的样式都可以通过css样式表修改。[/tipblock]\n[table][table-title]标签介绍[/table-title][tr][td][lcode]m-modal[/lcode][/td][td]主容器[/td]\n[/tr][tr][td][lcode]m-modal-page[/lcode][/td][td]内容容器，用于承载头部和弹窗的内容部分。[/td]\n[/tr][tr][td][lcode]m-modal-head[/lcode][/td][td]头部部分，包括标题和两个按钮。[/td][/tr][tr][td][lcode]m-modal-body[/lcode][/td][td]主内容部分，所有的HTML都将解析到此处。[/td][/tr][/table]\n应用到的类与属性：\n[b]1.[/b][lcode][m-modal-head-first-button][/lcode] 用于指定第一个按钮的css样式。\n[b]2.[/b][lcode][m-modal-head-title][/lcode] 用于指定标题的css样式。\n[b]3.[/b][lcode][m-modal-head-last-button][/lcode]用于指定第二个按钮的css样式。\n[b]4.[/b][lcode].in[/lcode]应用于[lcode]m-modal[/lcode]标签，将会同时改变[lcode]m-modal-page[/lcode]的样式，用于播放进入动画。默认动画时长0.6s。\n[b]5.[/b][lcode].out[/lcode]同上，用于播放出场动画。\n[b]6.[/b][lcode][mui-isopen][/lcode]是否打开。（true，false）\n[b]7.[/b][lcode][mui-uid][/lcode]组件的唯一标识，可以通过此标识来搭建一些功能如获取等。\n\n当然为了UI统一，我们设计了与此组件兼容的组件：\n\n[code]<m-modal-option>\n    <m-modal-option-item>\n        <p>文件大小</p>\n        <p>100MB</p>\n    </m-modal-option-item>\n    <m-modal-option-item>\n        <p>文件属性</p>\n        <p>GmicrantType文件</p>\n    </m-modal-option-item>\n</m-modal-option>[/code]\n样式仅在[lcode]m-modal-body[/lcode]中生效。\n\n[table][table-title]方法[/table-title][tr][td][lcode]init()[/lcode][/td][td]用于初始化组件，会在文档内的最后一行加入。[/td][/tr][tr][td][lcode]open()[/lcode][/td][td]打开[/td][/tr][tr][td][lcode]close()[/lcode][/td][td]关闭[/td][/tr][tr][td][lcode]update()[/lcode][/td][td]更新内部内容。[/td][/tr][tr][td][lcode]logout()[/lcode][/td][td]注销组件。将从文档中删除。[/td][/tr][tr][td][lcode]is_opening[/lcode][/td][td]是否打开。[/td][/tr][tr][td][lcode]uid[/lcode][/td][td]返回当前组件的唯一ID。[/td][/tr][/table]\n[warnblock]不支持动态更新！如果你修改了方法参数或属性，将不会生效[/warnblock]\n[lcode]mpopup[/lcode] 交互式或提示式弹窗\n该对象用于生成一个交互式或提示式弹窗。\n\n[tipblock]使用时注意避免层叠上下文错误，或自定义层叠上下文。[/tipblock]\n[code]mpopup.tip("你好",false) //生成一个提示框，橙色提示主题，非交互式。\nmpopup.warn("你好",true) //生成一个警告框，红色警告主题，交互式。\n[/code]\n弹窗的生成位置会在页面的右上方并一次叠加向下。\n在多个弹窗出现在页面上时，会依次向下叠加，并且会自动计算[lcode]margin-top[/lcode]以实现动态叠加。在处理时会在[lcode]m-popup[/lcode]标签上添加[lcode]mui-translateY[/lcode]以辅助计算。\n\n[warnblock]不要尝试修改[lcode]mui-translateY[/lcode]的参数值，会导致在计算叠加时出错。[/warnblock]\n\n[b]参数：[/b]\n[lcode]mpopup.tip(content, interactive)[/lcode]：[lcode]content[/lcode]为提示词，[lcode]interactive[/lcode]用于指定是否为交互式，默认不指定为[lcode]false[/lcode]指定时为[lcode]true[/lcode]。\n在不需要交互式时不指定此参数即可。默认将在5秒钟后消失。\n\n[tipblock]什么是交互式？\n交互式会在弹窗内多增一个“确定”按钮并且弹窗不会自动消失，仅会在点击按钮后消失。[/tipblock]\n\n[b]默认主题颜色：[/b]\n背景：提示[lcode]rgba(255, 0, 0, 0.482)[/lcode]；警告[lcode]#ffc300a6[/lcode]。\n字体：提示[lcode]#ff9600[/lcode]；警告[lcode]red[/lcode]。\n\n[table][table-title]标签[/table-title][tr][td][lcode]m-popup[/lcode][/td][td]主元素，所有内容都在此元素内。[/td][/tr][tr][td][lcode]m-popup-head[/lcode][/td][td]弹窗头部部分，用于显示图标与类型。[/td][/tr][tr][td][lcode]m-popup-body[/lcode][/td][td]内容显示部分。[/td][/tr][tr][td][lcode]m-popup-buttons[/lcode][/td][td]用于包裹交互式按钮。[/td][/tr][tr][td][lcode]m-popup-enter[/lcode][/td][td]交互式按钮。[/td][/tr][tr][td][lcode]m-popup-range[/lcode][/td][td]非交互式进度条，5秒钟。[/td][/tr][/table]\n`) + `<a href="javascript:mpopup.tip('提示框')">点击生成提示框</a><br><a href="javascript:mpopup.warn('警告框')">点击生成警告框</a><br><a href="javascript:mpopup.tip('提示框',true)">点击生成交互式提示框</a><br><a href="javascript:mpopup.warn('警告框',true)">点击生成交互式警告框</a>` + GmicrantType.encode(`\n代码：\n[code]mpopup.tip('提示框')\nmpopup.warn('警告框')\nmpopup.tip('提示框',true)\nmpopup.warn('警告框',true)\n[/code]\n\n[table][table-title]方法[/table-title][tr][td][lcode]tip(content, interactive)[/lcode][/td]\n[td]生成提示框，[lcode]content[/lcode]为提示文本。[lcode]interactive[/lcode]为是否为交互式（[lcode]true[/lcode]或[lcode]false[/lcode]）[/td][/tr][tr][td][lcode]warn(content, interactive)[/lcode][/td][td]生成警告框[/td][/tr][/table][hr/][lcode]mWindow[/lcode] 用于生成一个窗口\n示例代码：\n[code]const s = new mWindow({\n    size: {\n        width: 500,\n        height: 300\n    },\n    defaultLocation: {\n        x: 100,\n        y: 200\n    },\n    bgcolor: "white",\n    zIndex: 100000,\n    head: {\n        title: "测试",\n        controls: [\n            {\n                name: "关闭", func: close\n            }\n        ]\n    },\n    content: "MICROPUE窗口"\n})\nfunction close(){\n    si.close()\n}\ns.init()\ns.open()\n[/code]\n生成的HTML：\n\n[code]<m-window class="in" mui-uid="hakil6e825d"\n    style="--width: 500px; --height: 300px; --top: 160px; --left: 228px; --zIndex: 100000; --bgcolor: white; display: flex;"><m-window-head>\n        <m-window-title>测试</m-window-title>\n        <m-window-control>\n            <m-window-control-item>\n                <p>关闭</p>\n            </m-window-control-item>\n        </m-window-control>\n    </m-window-head>\n    <m-window-body>MICROPUE窗口</m-window-body>\n    <m-window-resize title="拖动以改变大小"></m-window-resize>\n</m-window>[/code]\n`) + `<a href="javascript:mwindow.open()">点击此处执行</a>` + GmicrantType.encode(`\n[b]方法与配置[/b]\n配置：\n\n[tipblock]⚠️注意：此组件是一个全局对象，在使用组件时，应避免命名冲突。[/tipblock]\n[code]const s = new mWindow({ //声明一个新的mWindow实例\n    size: { //默认大小\n        width: //宽度,\n        height: //高度\n    },\n    defaultLocation: { //默认位置\n        x: //横向位置,\n        y: //纵向位置\n    },\n    bgcolor: //背景颜色，使用css颜色即可 ,\n    zIndex: //层叠上下文,\n    head: {\n        title: //窗口标题,\n        controls: [\n            {\n                name: //控制按钮的名称, \n                func: //执行函数\n            },\n            {\n                name: //控制按钮的名称, \n                func: //执行函数\n            },\n            //支持多个按钮\n        ]\n    },\n    content: //HTML字符串，是窗口的主内容\n})\ns.init() //初始化\ns.is_init //是否已经初始化\ns.opened //是否打开\ns.open() //打开窗口\ns.close() //关闭窗口\ns.uid //窗口的唯一ID\ns.logout() //注销窗口\n[/code]\n在初始化窗口后，会在[lcode]body[/lcode]中添加窗口的HTML，默认情况下会在主标签：[lcode]m-window[/lcode]中添加参数：\n\n[table][tr][td][lcode]mui-uid[/lcode][/td][td]窗口的唯一ID[/td][/tr][tr][td][lcode]style[/lcode][/td][td]窗口的相应配置包括大小，位置等[/td][/tr][/table]\n由于组件需要动态更新，使用了相应的[lcode]css[/lcode]变量：\n\n[table][tr][td][lcode]--zIndex[/lcode][/td][td]层级[/td][/tr][tr][td][lcode]--top[/lcode][/td][td]距离顶部的距离[/td][/tr][tr][td][lcode]--left[/lcode][/td][td]距离左侧的距离[/td][/tr][tr][td][lcode]--bgcolor[/lcode][/td][td]背景颜色[/td][/tr][tr][td][lcode]--width[/lcode][/td][td]窗口宽度[/td][/tr][tr][td][lcode]--height[/lcode][/td][td]窗口高度[/td][/tr][/table]\n\n[tipblock]其中默认大小和默认位置也可以设置为[lcode]null[/lcode]将使用默认大小：[lcode]500*300[/lcode]，位置：[lcode]0,0[/lcode]\n\n[code]size: { //默认大小\n    width: null //宽度,\n    height: null//高度\n},\ndefaultLocation: { //默认位置\n    x: null//横向位置,\n    y: null//纵向位置\n},[/code][/tipblock]\n[b]方法[/b]\n\n[table][tr][td][lcode]init()[/lcode][/td][td]初始化组件，将会自动添加到[lcode]body[/lcode]中[/td][/tr][tr][td][lcode]is_init[/lcode][/td][td]是否已经初始化或添加[/td][/tr][tr][td][lcode]opened[/lcode][/td][td]是否已经打开[/td][/tr][tr][td][lcode]open()[/lcode][/td][td]打开[/td][/tr][tr][td][lcode]close()[/lcode][/td][td]关闭[/td][/tr][tr][td][lcode]logout()[/lcode][/td][td]注销[/td][/tr][tr][td][lcode]uid[/lcode][/td][td]窗口的唯一ID[/td][/tr][/table]\n[tipblock]拖动顶部半透明部分移动窗口，拖动右下角更改大小。[/tipblock]\n[warnblock][lcode]m-window[/lcode]仅针对电脑端适配，在小屏移动端或使用触屏效果可能不佳。[/warnblock]\n\n\n[lcode]m-tip[/lcode]\nhover提示小组件，通过将鼠标移动到父元素上显示该提示。\n用法：\n\n[code]<div> \x3C!-- 父元素 -->\n   <p>鼠标移到上面显示提示</p>\n   <m-tip> \x3C!-- 在父元素内部插入 -->\n      <p>这是提示</p>\n   </m-tip>\n</div>[/code]\n[tipblock]组件使用绝对定位并且嵌入父元素，在使用时应注意层叠上下文。\n父元素需要使用[lcode]position:relative;[/lcode][/tipblock]\n\n[lcode]m-loading[/lcode]\n加载条\n通过调用元素的[lcode]start()[/lcode]方法显示加载条，[lcode]end()[/lcode]方法关闭加载条。\n示例：\n[b]在页面上插入加载条[/b]\n[code]<body>\n <m-loading id="loadingbar"></m-loading>\n\x3C!-- ... -->\n\x3C/body>[/code]\n[b]在js中获取元素[/b]\n[code]const loadingbar = document.getElementById("loadingbar")\nloadingbar.start() //显示\nloadingbar.end() //关闭\n[/code]\n[tipblock]应自行设置[lcode]z-index[/lcode]的值，默认不指定。[/tipblock]`)}</div>`)
        }
        const editor = new BuiltGmicrantType()
        function gmicrant() {
            s.newPage(`编辑器构建`, '<div class="page" data-enable-lists>' + GmicrantType.encode(`[h2]使用GmicrantType语法进行文档构建[/h2]\n[h3]简介[/h3]\n[lcode]GimcrantType[/lcode]语法是由MICROPUE创建的文档编辑语法。与[lcode]Markdown[/lcode]不一样的是[lcode]GmicrantType[/lcode]拥有更简易的使用方法，更加的易于上手。并且针对[lcode]micropue.com.cn[/lcode]的优化，[lcode]GmicrantType[/lcode]的体验很好。\n最早[lcode]GmicrantType[/lcode]使用在[lcode]micropue.com.cn[/lcode]的社区功能中，可以对用户发布的帖子进行格式化，使其变得更加易读。\n随着[lcode]micropue.com.cn[/lcode]在10月28日的更新过后，MICROPUE开发了此文档语言，并应用在了所有具备文档编辑的功能区中。\n在[lcode]GmicrantType[/lcode]中，我们只需要使用类似[lcode]HTML[/lcode]的语法格式即可。[hr/][h3]创建编辑器[/h3]\n在引入[lcode]JavaScript[/lcode]文件后，可以使用内置类：[lcode]BuiltGmirantType[/lcode]进行构建。\n\n[code]const textarea = new BuiltGmicrantType()/* 声明一个BuiltGmicrantType类 */\ntextarea.init("#built-place")/* 初始化 */\n[/code]\n此操作会自动在指定位置生成一个编辑器。\n\n[tipblock]编辑器不会影响其他类名的定义，并且没有使用类名。\n生成的默认编辑器会默认填充满整个容器的宽度。高度不会自动改变但是可能会被父元素所影响。[/tipblock]\n通过改变[lcode]css[/lcode]来修改编辑器的默认样式：\n全局都使用[lcode][data-gmicrant-type][/lcode]进行选择\n\n[table][table-title]默认选择器[/table-title][tr][td][lcode][data-gmicrant-type=main][/lcode][/td][td]最外层[/td][/tr][tr][td][lcode][data-gmicrant-type=bar][/lcode][/td][td]功能栏[/td][/tr][tr][td][lcode][data-gmicrant-type=barbase][/lcode][/td][td]作为各个按钮的承载容器[/td][/tr][tr][td][lcode][data-gmicrant-type=item][/lcode][/td][td]按钮[/td][/tr][tr][td][lcode][data-gmicrant-type=content][/lcode][/td][td]输入框与实时预览的部分[/td][/tr][tr][td][lcode][data-gmicrant-type=input][/lcode][/td][td]输入框[/td][/tr][tr][td][lcode][data-gmicrant-type=lhr][/lcode][/td][td]用于调整左右大小的竖线[/td][/tr][tr][td][lcode][data-gmicrant-type=output][/lcode][/td][td]输出框[/td][/tr][/table]\n下面是一个由该类生成的编辑器\n`) + `<div id="editor" data-page-loader-cantuse style="background-color:#fafafa; border-radius:10px; margin-top:20px;"></div>` + GmicrantType.encode(`[hr/][h3]方法与配置[/h3]\n[table][table-title]方法[/table-title][tr][td][lcode]init(element,defaultText)[/lcode][/td][td]初始化编辑器，[lcode]element[/lcode]用于指定容器[lcode]defaultText[/lcode]用于在初始化时默认显示的文本。（可选）[/td][/tr][tr][td][lcode]getData()[/lcode][/td][td]获取输入内容[/td][/tr][tr][td][lcode]getHTML()[/lcode][/td][td]获取编译内容[/td][/tr][/table][hr/]示例：\n\n[code]const editor = new BuiltGmicrantType() \neditor.init("#editor") //初始化可以不定义默认文本\neditor.getData() //获取输入数据\neditor.getHTML() //获取预览数据\n[/code][hr/][h3]使用css自定义组件样式[/h3]\n我们支持通过更改[lcode]css[/lcode]来修改默认编辑器的组件样式，可以在UI库的[lcode]css[/lcode]样式表文件中修改。\n下面的表格中，将通过css选择器的方式进行展示。\n\n[table][table-title]使用到的css类名或标签（仅展示可更改项目）[/table-title][tr][td]标题1 - 标题6[/td][td]仅标题1-标题4支持左侧蓝色短线。[lcode].h1,.h2,.h3,.h4[/lcode][/td][/tr][tr][td]横线[/td][td][lcode]m-hr[/lcode][/td][/tr][tr][td]提示文本[/td][td][lcode].tip[/lcode][/td][/tr][tr][td]提示块[/td][td][lcode].tipblock[/lcode][/td][/tr][tr][td]警告快[/td][td][lcode].warnblock[/lcode][/td][/tr][tr][td]小代码区[/td][td][lcode].lblock[/lcode][/td][/tr][tr][td]代码域[/td][td][lcode].code[/lcode][/td][/tr][tr][td]表格[/td][td][lcode]m-table[/lcode][/td][/tr][tr][td]表格标题[/td][td][lcode]m-table-title[/lcode][/td][/tr][tr][td]表格行[/td][td][lcode]m-tr[/lcode][/td][/tr][tr][td]表格纵[/td][td][lcode]m-td[/lcode][/td][/tr][/table]\n[warnblock]由于使用了事件监听器，在搭配动态页面规划实例时，切换页面会导致监听器失效。可以为承载元素添加[lcode]data-page-loader-cantuse[/lcode]属性，可以在页面进行切换期间，自动遮盖。[/warnblock][hr/][h3]语法[/h3]\n[table][tr][td]加粗[/td][td][lcode][ b ][ /b ][/lcode][/td][/tr][tr][td]斜体[/td][td][lcode][ i ][ /i ][/lcode][/td][/tr][tr][td]删除线[/td][td][lcode][ s ][ /s ][/lcode][/td][/tr][tr][td]模糊文本[/td][td][lcode][ blur ][ /blur ][/lcode][/td][/tr][tr][td]标题1-标题6[/td][td][lcode][ h1 ][ /h1 ][/lcode]-[lcode][ h6 ][ /h6 ][/lcode][/td][/tr][tr][td]下划线[/td][td][lcode][ u ][ /u ][/lcode][/td][/tr][tr][td]横线[/td][td][lcode][ hr/ ][/lcode][/td][/tr][tr][td]提示文本[/td][td][lcode][ tip ][ /tip ][/lcode][/td][/tr][tr][td]提示块[/td][td][lcode][ tipblock ][ /tipblock ][/lcode][/td][/tr][tr][td]警告块[/td][td][lcode][ warnblock ][ /warnblock ][/lcode][/td][/tr][tr][td]小代码区[/td][td][lcode][ lcode ][ /lcode ][/lcode][/td][/tr][tr][td]代码域[/td][td][lcode][ code ][ /code ][/lcode][/td][/tr][tr][td]蓝色文本[/td][td][lcode][ blue ][ /blue ][/lcode][/td][/tr][tr][td]黄色文本[/td][td][lcode][ yellow ][ /yellow ][/lcode][/td][/tr][tr][td]红色文本[/td][td][lcode][ red ][ /red ][/lcode][/td][/tr][tr][td]表格[/td][td][lcode][ table ][ /table ][/lcode][/td][/tr][tr][td]表格标题[/td][td][lcode][ table-title ][ /table-title ][/lcode][/td][/tr][tr][td]表格行[/td][td][lcode][ tr ][ /tr ][/lcode][/td][/tr][tr][td]表格纵[/td][td][lcode][ td ][ /td ][/lcode][/td][/tr][tr][td]链接[/td][td][lcode][ link ][ /link ][/lcode][/td][/tr][tr][td]字体颜色[/td][td][lcode][ color:十六进制颜色或css颜色 ][ /color ][/lcode][/td][/tr][tr][td]字体大小[/td][td][lcode][ size:字体大小（数字0-50） ][ /size ][/lcode][/td][/tr][tr][td]高亮[/td][td][lcode][ highlight ][ /highlight ][/lcode][/td][/tr][tr][td]分数[/td][td][lcode][ frac ]分子\\分母[ /frac ][/lcode][/td][/tr][tr][td]次方[/td][td][lcode][ pow:乘方数或公式 ][ /pow ][/lcode][/td][/tr][tr][td]下角标[/td][td][lcode][ sub:数字或公式 ][ /sub ][/lcode][/td][/tr][tr][td]根式[/td][td][lcode][ sqrt:数字或公式 ][ /sqrt ][/lcode][/td][/tr][tr][td]数学公式区域[/td][td][lcode][ math ][ /math ][/lcode]，会自动将公式横向居中，并使用[lcode]Time New Roman[/lcode]字体[/td][/tr][/table]\n[tipblock]去除空格后使用[/tipblock]`) + '</div>')
            const ready = new MutationObserver(() => {
                editor.init("#editor", "[h1]欢迎使用GmicrantType编辑器[/h1]")
            })
            ready.observe(document.querySelector("#main .container"), { childList: true, subtree: true })
            setTimeout(() => {
            }, 300)
        }
        const route = [
            ["/start", start],
            ["/functions", functionsAndMethods],
            ["/models", models],
            ["/gmicranttype", gmicrant]
        ]
        const router = new RouteLoader(route)
    </script>
</body>

</html>